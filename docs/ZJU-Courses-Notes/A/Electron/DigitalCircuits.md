
# Chap IV 数字集成电路

!!! quote
	如果我们将表达逻辑的布尔代数运用到电路上, 那么对电路一种新的设计思路就出现了. 这便是数字电路. 因为仅仅少量的几种门电路即可表达复杂的逻辑, 因此我们将这些最基本的门电路集成到了一块芯片上, 这便是数字集成电路. 对于此类集成电路, 我们不关心里面究竟是如何实现的, 我们也不需要用到复杂的电路知识, 因为这种集成电路已经把复杂的电路定律转化为了简洁的逻辑表达式.

## 逻辑代数运算

---

逻辑代数有三种基本运算, 分别是: 与($\&$), 或($+$), 非. 运算规则如下

![](https://pan.xxbyq.net/f/PpAIy/%E6%88%AA%E5%B1%8F2025-11-30%2013.13.57.png)

![](https://pan.xxbyq.net/f/DbKfx/%E6%88%AA%E5%B1%8F2025-11-30%2013.15.06.png)

注意, 其中的反演律并不是只适用于三个元素的情况. 其准确的表达式应该为:

$$
\overline{\prod_{i=1}^nX_i}=\sum_{i=1}^n\overline{X_i},\ \ \ \ \overline{\sum_{i=1}^n X_i}=\prod_{i=1}^n\overline {X_i}
$$

对于逻辑表达式的化简, 一般是最终最多只有一个非运算, 并尽可能地简化. 本课程对化简的要求不高, 因此掌握前面提及的这一点即可.

## 逻辑函数

---

逻辑函数可以使用逻辑状态表, 逻辑表达式, 逻辑图三种等效表示. 具体的写法, 规则, 参照下面例题即可.

![](https://pan.xxbyq.net/f/E7MCz/%E6%88%AA%E5%B1%8F2025-11-30%2013.21.30.png)

![](https://pan.xxbyq.net/f/oJ5S1/%E6%88%AA%E5%B1%8F2025-11-30%2013.21.44.png)

![](https://pan.xxbyq.net/f/wBvIk/%E6%88%AA%E5%B1%8F2025-11-30%2013.22.06.png)

另外补充强调, 从逻辑状态表逆推逻辑表达式时十分推荐使用"且-或"的形式写逻辑表达式, 是因为这样可以做到"不重不漏".

## 集成门电路的类型

---

![](https://pan.xxbyq.net/f/WMoFQ/%E6%88%AA%E5%B1%8F2025-11-30%2013.26.35.png)

(因为上课时没有细讲, 并且课后作业也没有相关内容, 因此 TTL 门电路的原理此处略过不讲)

## 集成触发器

---

### RS 触发器

![](https://pan.xxbyq.net/f/YD5t0/%E6%88%AA%E5%B1%8F2025-11-30%2013.31.43.png)

上图是一个典型的 RS(Reset-Set) 触发器电路原理图. 我们逐个分析其状态和结果:


| $\overline S$ | $\overline R$ | $Q$ | $\overline Q$ | 分析                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ------------- | ------------- | --- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| $0$           | $0$           | $-$ | $-$           | 不能确定, 取决于 $\overline S$ 和 $\overline R$ 谁输入的信号快. 通过假设在输入两个信号前 $Q$ 和 $\overline Q$ 的几种情况进行分析, 这里不多赘述.                                                                                                                                                                                                                                                                                                                            |
| $0$           | $1$           | $1$ | $0$           | 首先 $\overline S$ 输入 $0$, 那么 $Q$ 输出一定为 $1$; $Q$ 输入到 $G_2$, 此时 $\overline R$ 与 $Q$ 都为 $1$, 因此 $\overline Q$ 输出一定为 $0$. **我们称此输入为置位(Set)**                                                                                                                                                                                                                                                                                         |
| $1$           | $0$           | $0$ | $1$           | 首先 $\overline R$ 输入 $0$, 那么 $\overline Q$ 输出一定为 $1$; $\overline Q$ 输入到 $G_1$, 此时 $\overline S$ 与 $\overline Q$ 都为 $0$, 因此 $Q$ 输出一定为 $0$, **我们称此为复位(Reset)**                                                                                                                                                                                                                                                                     |
| $1$           | $1$           | $-$ | $-$           | 二者都为 $1$, 是不能直接确定当前状态的, 单独分析也是没有意义的. 实际上, 分析此种状态的前提是已知 $Q$ 和 $\overline Q$ 的状态. 若 $Q=\overline Q=0$, 那么一旦接入就立刻跳变为 $Q=1$, $\overline Q=0$ 或者 $\overline Q=1$, $Q=0$, 具体取决于 $\overline S$ 和 $\overline R$ 谁先设置为 $1$. 这种分析同样是没有意义的. 讨论 $Q=\overline Q=1$ 时同样如此. 若讨论 $Q=1$ 且 $\overline Q=0$ 或者 $Q=0$ 且 $\overline Q=1$ 两种情况, 我们发现这种输入对于 $Q$, $\overline Q$ 是没有改变的. 因此, **我们称这种状态为保持(Hold On), 即输出端输出信号不变, 并且一般只允许两个输出端输出逻辑相反时使用**. |

从上面的分析中我们不难发现, 相较于普通的门电路, 触发器的输出状态(我们定义为**次态**, 记作 $Q^{n+1}$)不但和当前的输入相关, 还和上一轮的输出(我们定义为**原态**, 记作 $Q^n$)相关.

RS 触发器正常工作时, 输出的两端 $Q$ 和 $\overline Q$ 是反向的, 并且**绝对不允许出现上表中第一行对应的输入情况**.

![](https://pan.xxbyq.net/f/qRqT7/%E6%88%AA%E5%B1%8F2025-11-30%2014.03.32.png)

### 同步 RS 触发器与 D 锁存器

![](https://pan.xxbyq.net/f/ypQcZ/%E6%88%AA%E5%B1%8F2025-11-30%2014.05.24.png)

上图是同步 $RS$ 触发器, 可以看到多了一个 $CP$ 时钟脉冲(Clock Pulse)输入端. $CP$ 时钟脉冲的功能是控制电路中的元件在同一时间做对应的任务, 防止因为不同元件延迟不同或者运行频率不同导致逻辑混乱(比如输入的是下一秒的内容, 而我需要处理的是上一秒的内容, 输出自然也就不对了). 带有 $CP$ 引脚的触发器都称为同步触发器. 

只有当 $CP$ 发出特定脉冲信号时元件才进行运算, 我们称这种模式为"触发".

有关本电路的其他细节这里不多做分析(孙晖老师上课也没细讲. 本章前言已经说了, 本章关键是直接用抽象的逻辑语言代替复杂的实际电路结构, 因此很多内部原理不需要非常清楚), 只需要知道, $\overline {S_d}$ 和 $\overline {R_d}$ 有着最高权限, 可以直接将 $Q$ 和 $\overline Q$ 设置为 $10$ 或者 $01$.

![](https://pan.xxbyq.net/f/jmPfB/%E6%88%AA%E5%B1%8F2025-11-30%2014.14.26.png)

上面这幅图是高电平触发的 D 触发器的结构, 其特点是, 每当高电平激活时:

$$
Q^{n+1}=D
$$

我们称上面这种方程为特征方程. 

非高电平时保持 $Q$ 不变.

当然, 除了高电平触发这一种模式, 还存在边沿触发类型:

![](https://pan.xxbyq.net/f/AmqtP/%E6%88%AA%E5%B1%8F2025-11-30%2014.19.51.png)

![](https://pan.xxbyq.net/f/n7ptL/%E6%88%AA%E5%B1%8F2025-11-30%2014.20.42.png)

![](https://pan.xxbyq.net/f/gkLhe/%E6%88%AA%E5%B1%8F2025-11-30%2014.21.36.png)

### 负边沿触发的 JK 触发器

![](https://pan.xxbyq.net/f/LOMtJ/%E6%88%AA%E5%B1%8F2025-11-30%2014.22.56.png)

上图是负边沿触发的 JK 触发器图形符号. $(b)$ 图相较于 $(a)$ 的唯一区别是内置了两个与门运算. JK 触发器的特征方程为:

$$
Q^{n+1}=J\overline{Q^n}+\overline KQ^n
$$

如果 $J=K$, 很容易发现这是一个异或运算. 我们将这一变种称为 $T$ 触发器.

### T 触发器

![](https://pan.xxbyq.net/f/ZENF0/%E6%88%AA%E5%B1%8F2025-11-30%2014.29.04.png)

特征方程就是:

$$
Q^{n+1}=T\overline {Q^n}+\overline TQ^n
$$

若我们保持 $T=1$, 则 $Q^{n+1}=\overline{Q^n}$, 即输出的 $Q$ 与上一轮的 $Q$ 恰好相反, 并且翻转与时间脉冲负边沿信号频率相同. $T$ 触发器常常用在计数电路中.

