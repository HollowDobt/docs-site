# 面向对象程序设计: 基于 C++

!!! abstract
	本文是基于 C++ 的面向对象程序设计的笔记. 参考内容为 *C++ Primer 5th* 第 7 章, 第 14 章有关类的部分, *c++ reference* 网站, 以及一些 github 上的项目实例. 参考标准为 *C++17*, 但特性基本取自 *C++11*. 题目大部分是笔者自编的, 未说明部分请自行使用 AI 检查答案.

## Chap ZERO C++ 内存管理机制
---
### 0. 1 内存
在 C++ 中, 内存中存在下面几个区域:

| 区域       | 生命周期    | 典型实例                      |
| -------- | ------- | ------------------------- |
| 栈(Stack) | 作用域自动释放 | 局部变量, 函数参数                |
| 堆(Heap)  | 手动申请释放  | 传统方式为 `new` 与 `delete` 申请 |
| 全局区      | 程序整个周期  | 全局变量, 静态变量                |

!!! note
	**作用域**: 指变量或函数在程序中允许被访问的区域. 例如, 对于下面这段程序, 我们定义的变量 `a` 在全局可以访问, `a` 的作用域就是整个程序.
	
	```cpp
	#include <iostream>
	using namespace std;
	
	int a = 0;
	
	int main() {
		cout << a << endl;
	}
	```

### 0. 2 堆上单变量型内存分配
堆上的内存分配需要程序员手动控制. 在传统的 C++编程中, 我们一般使用 `new` 和 `delete` 进行内存分配. 例如

```cpp
#include <iostream>
using namespace std;

int main() {
	int *ptr = new int(42); // 分配一个 int 类型内存区段在堆中, 存储的数据为 42, 让位于栈上的整型指针 ptr 指向这个内存区段的第一位
	cout << *ptr << endl;
	delete ptr; // 销毁指针指向的内存区段.
	return 0;
}
```

虽然我们分配的内存在堆上, 但是指向这段内存的指针仍然是在栈上的. 栈上的内存是由作用域自动释放的, 我们无法手动控制, 因此我们 `delete` 的实际上不是 `ptr` 指针, 而是指针指向的内存区段. 也就是说, 指针在 `delete` 的时候没有自动被销毁.

这也是 C++ 最令人头疼的地方之一. 我们如果按照示例的方式写, 在我们写大型项目的时候很可能会出现"垂悬指针"或者说"野指针"的问题, 而且编译器无法在编译阶段发现问题. 因此, 我们应当在销毁内存后让指针回到 `nullptr`.

```cpp
#include <iostream>
using namespace std;

int main() {
	int *ptr = new int(42);
	cout << *ptr << endl;
	delete ptr;
	ptr = nullptr; // 指针失效后一定要 nullptr
	return 0;
}
```

总结一下, 我们写 C++ 程序的时候用到堆必须有的动作

| 关键字与语句          | 结果                                                                                |
| --------------- | --------------------------------------------------------------------------------- |
| `new`           | 新开一个堆区段.                                                                          |
| `delete`        | 删除一个堆区段. 堆上分配的内存无法自动销毁, 不用的内存大量堆积会导致内存泄漏                                          |
| `ptr = nullptr` | 将指针置空. 大型程序中如果不置空, 可能在后面误用导致野指针问题. 问题常常难以发现甚至程序本身可以正常工作, 但是一定会造成严重的安全隐患(如非法篡改内存). |

### 0. 3 堆上数组型内存分配
上面我们讨论的是单个变量的堆上内存分配. 对于数组对象, 我们应当使用 `delete[]` 进行销毁

```cpp
#include <iostream>
using namespace std;

int main() {
	cin >> n;
	int *ptr = new int[n];
	delete[] ptr;
	ptr = nullptr;
	return 0;
}
```

如果我们用 `delete`, 那么只有被 `ptr` 指向的内存区段的第一项被删除.

!!! question
	**何时使用 `delete`, 何时使用 `delete[]` ?** 答: `new ...()` 初始化时使用 `delete`, `new ...[]` 初始化时使用 `delete[]`.
	
	**不是只要是数组都必须 `delete[]`**. 例如
	
	```cpp
	class arrayD {
	 public:
		int arr[10]; 
	};
	
	int main() {
		arrayD *ptr = new arrayD();
		return 0;
	}
	```
	
	换言之, `delete` 还是 `delete[]` 只取决于初始化或者说 `new` 的方式. 如果我们 `new` 的是一个对象, 那么删除的时候自然只需要删掉这一个对象. 如果我们用的是 `new ...[]`, 也就是一个对象的数组, 那么我们就要调用 `delete[]`.

### 0.4 Practice

!!! warning
	题目中出现的动态数组并不推荐大家在生产实际中使用. 建议使用 `vector`. 此处使用手动分配堆仅仅是为了让大家熟悉 `new` 和 `delete` 的用法

- 使用 `new` 申请一个 `int`, 然后赋值为 `123`, 输出地址和值, 释放内存.
- 不使用 `vector`, 读入一个正整数 `N` (保证 $N<10$), 而后输入 `N` 个数, 输出所有数的和, 并正确释放内存.
- 不使用 `vector`, 读入行数 `R` 与列数 `L`, 创建一个矩阵, 读入 $L\times R$ 个数, 而后计算矩阵内所有数的和, 并正确释放内存.

!!! tip
	**最后一题相关提示**: C++ 中并不支持 `new [][]` 这种写法. 下面展示一种常见解决方案
	
	```cpp
	#include <iostream>
	using namespace std;
	
	int main() {
		int R = 0, L = 0;
		cin >> R >> L;
		int **ptr = new int *[R];
		int *ptrD = new int [R * L];
		for (int i = 0; i < R; i ++) {
			ptr[i] = ptrD + i * L;
		}
		
		delete[] ptrD;
		delete[] ptr;
		
		return 0;
	}
	```
	
	碎碎念一下, 不过相信大家不可能出现下面的错误.
	
	一开始我对这个程序其实抱有疑惑. **我们 `delete[] ptr` 的时候有没有删掉 `ptrD`?** 如果删掉了, 那么和前面的 `delete` 删不掉栈上面分配的内存这一说法就产生了矛盾. 我真是糊涂了, 实际上, 确实**没有删掉**. 我们从内存角度看, 从始至终栈上面只有两个指针变量, 一个叫 `ptr`, 另一个叫 `ptrD`. 而堆上有两段新开的内存区段, 一个是 `ptr` 指向的 `A` 区段, 另一个是 `ptrD` 指向的 `B` 区段, 其中 `A` 中存储的是指向 `B` 中某些单变量的指针. 我们 `delete` 掉的都是这些存储在堆中的东西, 不论是值还是指针.

### 0. 5 智能指针

传统的 `new` 和 `delete` 是否完美无缺呢? 答案自然是否定的. 

首先是多个 `new` 和 `delete` 使用的时候程序可读性会变得相当糟糕. 如果只是一个人进行程序编写尚可接受, 但是在现代多协作的代码工程中我们必须要和团队配合. 或许我们自己不容易忘记, 但是我们的团队成员呢?

除此之外, 在遇到错误的时候 C++ 会触发栈展开, 直接跳过域内代码导致后面所有可能的 `delete` 都得不到执行. 除非程序直接崩溃由操作系统回收内存资源, 否则会造成严重的内存泄漏隐患.

!!! note
	**栈展开**: C++ 中的异常处理机制, 当程序遇到异常抛出后, 程序会递归式从当前所在函数中的对象开始调用析构函数, 逐层退出函数, 直到找到恰当的异常处理代码为止.
	
	也就是说, 这一异常处理过程中 C++ 没有动堆上的内存, 也就是没有 `delete` 的过程.

!!! note
	**RAII**原则: 就是指 Resource Acquisition Is Initialization, "资源获取即初始化". 在指针方面, 堆上一旦有新空间开辟, 就需要立刻有一个指针管理这一片空间; 而当指针这一管理者消失时, 这片空间就立刻被回收. 严格遵守 RAII 原则可以减少大部分堆内存分配问题.

为了尽可能避免传统堆内存管理中遇到的问题, 现代 C++ 设计了智能指针 `unique_ptr` 和 `shared_ptr`. 智能指针的特点是引入了"生命周期", 也就是"引用计数". 每当我们在堆上新开一个内存区段时, 就自动新建一个引用计数器, 记录指向这一内存区段的指针数. 当计数归零时, 这段内存将通过析构函数回收. 通过这一方式, 我们便可以像使用普通指针那样使用指向堆的指针.

!!! note
	**生命周期机制的合理性**: 首先对于一个栈上的内存, 其销毁机制本身就类似于生命周期. 例如, 一个变量 `i` 定义在某个 `for` 循环中, 那么脱离了 `for` 循环这个作用域变量自己就会被销毁, 并且不允许在作用域外被访问. 这一点即使是静态检查器也可以实现. 智能指针就是这样.
	
	但是, 二者本质上是不一样的. 指向栈上内存的指针在退出作用域时内存部分会直接被栈机制回收, 而不依赖引用计数. 换句话说, 指向栈上内存的指针的生命周期机制不依赖引用计数, 而是直接依赖作用域机制.

但是, 智能指针是完美的吗? 答案是否定的. 其中最典型的例子就是**循环引用**问题. 例如下面这段程序

```cpp
#include <memory>

using namespace std;

class B;

class A {
   public:
    shared_ptr<B> ptr;
};

class B {
   public:
    shared_ptr<A> ptr;
};

int main(void) {
    auto a = make_shared<A>();
    auto b = make_shared<B>();
    a->ptr = b;
    b->ptr = a;

    return 0;
}
```

当对象 A 引用了对象 B, 而对象 B 又反过来引用了对象 A. 就形成了一个循环引用. 在使用基于引用计数的垃圾回收机制时, A 和 B 虽然都已不再被程序的其他部分使用, 但由于互相之间仍持有引用, 它们的引用计数始终不为 0, 因此无法被回收, 最终可能导致内存泄漏.

当然, 其实智能指针的"坑"很多. 而且作为一种本质上手动管理内存的机制, 相比于 Java 的垃圾回收机制其可能仍然存在诸多问题. 但相较于传统的 `new` 和 `delete`, 现代 C++ 通过明确对象与资源的关系很大程度上减少了内存风险. 在实际开发中, 仍然推荐使用智能指针.

智能指针分为三类, 分别为

| 类型         | 特点                                    | 实例                                                                  |
| ---------- | ------------------------------------- | ------------------------------------------------------------------- |
| unique_ptr | 引用计数只允许为 0 或者 1. 也就是某一个内存区段只允许被一个指针指向 | `unique_ptr<int> num = make_unique<int>(20);`                       |
| shared_ptr | 允许同一个内存区段被多次引用, 引用计数可以为任何非负整数.        | `shared_ptr<int> num = make_shared<int>(20);`                       |
| weak_ptr   | 不会增加引用计数. 常常用于解决循环引用问题.               | (不允许被直接 `make`, 因为仅依赖于已存在的 `shared` 指针) `weak_ptr<int> num2 = num;` |


## Chap I 如何定义一个类?
---
类的基本思想是**数据抽象**和**封装**. 我们将**接口**和**实现**相分离, 用户不需要知道一个函数是如何实现的, 他们只需要知道接口的标准和功能即可; 接口的实现由类的设计者完成.

### 1. 1 定义一个类
```cpp
class 
```