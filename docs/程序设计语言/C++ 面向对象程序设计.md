# 面向对象程序设计: 基于 C++

!!! abstract
	本文是基于 C++ 的面向对象程序设计的笔记. 参考内容为 *C++ Primer 5th* 第 7 章, 第 14 章有关类的部分, *c++ reference* 网站, 以及一些 github 上的项目实例. 题目大部分是笔者自编的, 未说明部分请自行使用 AI 进行答案检查.

## Chap ZERO C++ 内存管理机制
---
### 0. 1 内存
在 C++ 中, 内存中存在下面几个区域:

| 区域       | 生命周期    | 典型实例                      |
| -------- | ------- | ------------------------- |
| 栈(Stack) | 作用域自动释放 | 局部变量, 函数参数                |
| 堆(Heap)  | 手动申请释放  | 传统方式为 `new` 与 `delete` 申请 |
| 全局区      | 程序整个周期  | 全局变量, 静态变量                |

!!! note
	**作用域**: 指变量或函数在程序中允许被访问的区域. 例如, 对于下面这段程序, 我们定义的变量 `a` 在全局可以访问, `a` 的作用域就是整个程序.
	
	```cpp
	#include <iostream>
	using namespace std;
	
	int a = 0;
	
	int main() {
		cout << a << endl;
	}
	```

### 0. 2 堆上单变量型内存分配
堆上的内存分配需要程序员手动控制. 在传统的 C++编程中, 我们一般使用 `new` 和 `delete` 进行内存分配. 例如

```cpp
#include <iostream>
using namespace std;

int main() {
	int *ptr = new int(42); // 分配一个 int 类型内存区段在堆中, 存储的数据为 42, 让位于栈上的整型指针 ptr 指向这个内存区段的第一位
	cout << *ptr << endl;
	delete ptr; // 销毁指针指向的内存区段.
	return 0;
}
```

虽然我们分配的内存在堆上, 但是指向这段内存的指针仍然是在栈上的. 进一步讲, 栈上的内存是由作用域自动释放的, 我们无法手动控制, 因此我们 `delete` 的实际上不是 `ptr` 指针, 而是指针指向的内存区段.

这也是 C++ 最令人头疼的地方之一. 我们如果按照示例的方式写, 在我们写大型项目的时候很可能会出现"垂悬指针"或者说"野指针"的问题, 而且编译器无法在编译阶段发现问题. 因此, 我们应当形成习惯, 在销毁内存后让指针回到 `nullptr`, 好让编译器更容易检查到错误

```cpp
#include <iostream>
using namespace std;

int main() {
	int *ptr = new int(42);
	cout << *ptr << endl;
	delete ptr;
	ptr = nullptr; // 指针失效后一定要 nullptr
	return 0;
}
```

总结一下, 我们写 C++ 程序的时候用到堆必须有的动作

| 函数              | 目的与后果                                                                             |
| --------------- | --------------------------------------------------------------------------------- |
| `new`           | 新开一个堆区段.                                                                          |
| `delete`        | 删除一个堆区段. 堆上分配的内存无法自动销毁, 不用的内存大量堆积会导致内存泄漏                                          |
| `ptr = nullptr` | 将指针置空. 大型程序中如果不置空, 可能在后面误用导致野指针问题. 问题常常难以发现甚至程序本身可以正常工作, 但是一定会造成严重的安全隐患(如非法篡改内存). |

### 0. 3 堆上数组型内存分配
上面我们讨论的是单个变量的堆上内存分配. 对于数组对象, 我们应当使用 `delete[]` 进行销毁

```cpp
#include <iostream>
using namespace std;

int main() {
	cin >> n;
	int *ptr = new int[n];
	delete[] ptr;
	ptr = nullptr;
	return 0;
}
```

如果我们用 `delete`, 那么只有被 `ptr` 指向的内存区段的第一项被删除.

!!! note
	**何时使用 `delete`, 何时使用 `delete[]` ?** `new ...()` 时使用 `delete`, `new ...[]` 时使用 `delete[]`.
	
	首先必须澄清一点, 就是实际上**不是只要是数组都必须 `delete[]`**. 例如
	
	```cpp
	class arrayD {
	 public:
		int arr[10]; 
	};
	
	int main() {
		arrayD *ptr = new arrayD();
		return 0;
	}
	```
	
	换言之, 就是 `delete` 还是 `delete[]` 只取决于初始化或者说 `new` 的方式. 如果我们 `new` 的是一个对象, 那么删除的时候自然只需要删掉这一个对象. 如果我们用的是 `new ...[]`, 也就是说是一个对象的数组, 那么我们就要调用 `delete[]`.

### 0.4 Practice

!!! warning
	题目中出现的动态数组并不推荐大家在生产实际中使用. 建议使用 `vector`. 

- 使用 `new` 申请一个 `int`, 然后赋值为 `123`, 输出地址和值, 释放内存.
- 不使用 `vector`, 读入一个正整数 `N` (保证 $N<10$), 而后输入 `N` 个数, 输出所有数的和, 并正确释放内存.
- 不使用 `vector`, 读入行数 `R` 与列数 `L`, 创建一个矩阵, 读入 $L\times R$ 个数, 而后计算矩阵内所有数的和, 并正确释放内存.

!!! tip
	**最后一题相关提示**: C++ 中并不支持 `new [][]` 这种写法. 因此, 只能考虑使用"指向指针的指针"来解决这一问题. 下面是一种比较常用的不使用类完成这一过程的方法
	
	```cpp
	#include <iostream>
	using namespace std;
	
	int main() {
		int R = 0, L = 0;
		cin >> R >> L;
		int **ptr = new int *[R];
		int *ptrD = new int [R * L];
		for (int i = 0; i < R; i ++) {
			ptr[i] = ptrD + i * L;
		}
		
		delete[] ptrD;
		delete[] ptr;
		
		return 0;
	}
	```
	
	一开始我对这个程序其实抱有疑惑. **我们 `delete[] ptr` 的时候有没有删掉 `ptrD`?** 如果删掉了, 那么和前面的 `delete` 删不掉栈上面分配的内存这一说法就产生了矛盾. 实际上, 确实**没有删掉**. 我们从内存角度看, 从始至终栈上面只有两个指针变量, 一个叫 `ptr`, 另一个叫 `ptrD`. 而堆上有两段新开的内存区段, 一个是 `ptr` 指向的 `A` 区段, 另一个是 `ptrD` 指向的 `B` 区段, 其中 `A` 中存储的是指向 `B` 中某些单变量的指针. 我们 `delete` 掉的都是这些存储在堆中的东西, 不论是值还是指针.
	
	进一步, 我们思考上述程序中 `delete[] ptrD` 和 `delete[] ptr` 可不可以交换顺序? 答案是理论上没问题, 但除非我们删掉 `ptr` 后立刻删掉 `ptrD`, 不推荐这么写. 具体原因仍然是可能产生野指针问题.


## Chap I 如何定义一个类?
---
类的基本思想是**数据抽象**和**封装**. 我们将**接口**和**实现**相分离, 用户不需要知道一个函数是如何实现的, 他们只需要知道接口的标准和功能即可; 接口的实现由类的设计者完成.

### 1. 1 定义一个类
```cpp
class 
```