
# Project 0 Game 2048

## 仓库地址

- 模板 <https://github.com/Berkeley-CS61B/skeleton-sp21/tree/master/proj0>
- 实现 

## 辅助函数实现

### emptySpaceExists(Board b)

阅读 `Board.java` 文件, 确定 `tile(int col, int row)` 与 `size()` 方法是什么怎么用即可完成.

```java
/** Return the current Tile at (COL, ROW), where 0 <= ROW < size(),  
 *  0 <= COL < size(). Returns null if there is no tile there. */
public Tile tile(int col, int row) {  
    return vtile(col, row, viewPerspective);  
}

/** Returns the size of the board. */  
public int size() {  
    return values.length;  
}
```

参考实现

```java
/** Returns true if at least one space on the Board is empty.  
 *  Empty spaces are stored as null. * */
public static boolean emptySpaceExists(Board b) {  
    // TODO: Fill in this function.  
  
    for (int i = 0; i < b.size(); ++i) {  
        for (int j = 0; j < b.size(); ++j) {  
            if (b.tile(i, j) == null) {  
                return true;  
            }  
        }  
    }  
  
    return false;  
}
```

### maxTileExists(Board b)

项目文档有意引导大家养成良好的编码习惯, 即不要在程序中直接使用数字或者字符串硬编码. 不然, 一旦有跨平台的需求或者需要修复某些 `bug` 的时候就会产生严重的灾难.

同样很简单, 注释中说明了 `value()` 是 `Tile` 类型的方法, 因此直接从当前的 `Tile` 读取 `value` 判断是否达到 `MAX_PIECE` 即可.

需要注意的一点是, `value()` 方法调用前不会检查调用这一函数的对象是否真的能够调用. 如果上一个函数出现了 `null` 的情况, 那么调用 `value()` 就一定会抛出错误.

参考实现

```java
/**  
 * Returns true if any tile is equal to the maximum valid value. 
 * Maximum valid value is given by MAX_PIECE. Note that 
 * given a Tile object t, we get its value with t.value(). */
public static boolean maxTileExists(Board b) {  
    // TODO: Fill in this function.  
  
    for (int i = 0; i < b.size(); ++i) {  
        for (int j = 0; j < b.size(); ++j) {  
            Tile num = b.tile(i, j);  
            if (num != null && num.value() == MAX_PIECE) {  
                return true;  
            }  
        }  
    }  
  
    return false;  
}
```

### atLeastOneMoveExists(Board b)

相比于前两个辅助函数, 这一函数的实现的难度略微大一些. 首先对边界有两种思路, 其一是在边缘添加哨兵, 避免边界状况的发生; 其二是直接在边界状况发生的时候处理掉. 我们选择工程上更常见的方案二.

对于函数本身, 先判断是否有空格子, 如果有那么一定可以移动; 如果没有空格子, 那么可以判断一个格子周围的是否有值与之相同的格子. 如果有那么就可以合并, 可以移动. 具体实现时结合前面提到的边界处理思路完成代码.

```java
/**  
 * Returns true if there are any valid moves on the board. 
 * There are two ways that there can be valid moves: 
 * 1. There is at least one empty space on the board. 
 * 2. There are two adjacent tiles with the same value. */
public static boolean atLeastOneMoveExists(Board b) {  
    // TODO: Fill in this function.  
  
    if (emptySpaceExists(b)) {  
        return true;  
    }  
  
    int bSize = b.size();  
    for (int i = 0; i < bSize - 1; ++i) {  
        for (int j = 0; j < bSize - 1; ++j) {  
            if (b.tile(i, j).value() == b.tile(i, j + 1).value() ||  
                    b.tile(i, j).value() == b.tile(i + 1, j).value()) {  
                return true;  
            }  
        }  
    }  
  
    // Analyze the bottom right corner separately  
    if (b.tile(bSize - 1, bSize - 1).value() == b.tile(bSize - 2, bSize - 1).value() ||  
            b.tile(bSize - 1, bSize - 1).value() == b.tile(bSize - 1, bSize - 2).value()) {  
        return true;  
    }  
  
    return false;  
}
```