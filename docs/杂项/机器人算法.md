# 机器人算法

!!! abstract
	这一部分的完整代码实现在 github 的仓库中 <>. 此处给定代码功能主要为最小示例, 用于解释原理.

## ISR 中断服务
---

示例代码

```cpp
constexpr int ENCODER_1_A = A8;
constexpr int ENCODER_1_B = A9;
constexpr int ENCODER_2_A = A10;
constexpr int ENCODER_2_B = A11;
constexpr int ENCODER_3_A = A12;
constexpr int ENCODER_3_B = A13;
constexpr int ENCODER_4_A = A14;
constexpr int ENCODER_4_B = A15;
constexpr int ENCODER_LINES = 11;
constexpr unsigned long SAMPLE_PERIOD_MS = 100;  // 采样周期(ms)
unsigned long lastSampleTime = 0;
long lastPos[4] = {0};   // 上次脉冲数
float rpmFR = 0, rpmFL = 0, rpmBR = 0, rpmBL = 0;  // 四轮转速


volatile uint8_t lastState_PCINT = 0;
volatile long pos[4] = {0};   // 四路编码器脉冲计数

void ISR(PCINT2_vect) {
    uint8_t currentState = PINK;           // 读取A8~A15所有引脚状态
    uint8_t changedPins = currentState ^ lastState_PCINT; // 检测哪些引脚变化

    // 编码器1: PK0(A), PK1(B)
    if (changedPins & ((1 << 0) | (1 << 1))) {
        bool A = currentState & (1 << 0);
        bool B = currentState & (1 << 1);
        if (changedPins & (1 << 0)) {      // A跳变
            if (A == B) pos[0]++;
            else pos[0]--;
        } else {                           // B跳变
            if (A != B) pos[0]++;
            else pos[0]--;
        }
    }

    // 编码器2: PK2(A), PK3(B)
    if (changedPins & ((1 << 2) | (1 << 3))) {
        bool A = currentState & (1 << 2);
        bool B = currentState & (1 << 3);
        if (changedPins & (1 << 2)) {      // A跳变
            if (A == B) pos[1]++;
            else pos[1]--;
        } else {                           // B跳变
            if (A != B) pos[1]++;
            else pos[1]--;
        }
    }

    // 编码器3: PK4(A), PK5(B)
    if (changedPins & ((1 << 4) | (1 << 5))) {
        bool A = currentState & (1 << 4);
        bool B = currentState & (1 << 5);
        if (changedPins & (1 << 4)) {      // A跳变
            if (A == B) pos[2]++;
            else pos[2]--;
        } else {                           // B跳变
            if (A != B) pos[2]++;
            else pos[2]--;
        }
    }

    // 编码器4: PK6(A), PK7(B)
    if (changedPins & ((1 << 6) | (1 << 7))) {
        bool A = currentState & (1 << 6);
        bool B = currentState & (1 << 7);
        if (changedPins & (1 << 6)) {      // A跳变
            if (A == B) pos[3]++;
            else pos[3]--;
        } else {                           // B跳变
            if (A != B) pos[3]++;
            else pos[3]--;
        }
    }

    lastState_PCINT = currentState;        // 记录状态用于下次检测
}

void setup() {
    // 配置A8~A15为输入，并开启上拉
    for (int i = A8; i <= A15; i++) {
        pinMode(i, INPUT_PULLUP);
    }
    // 使能PCINT2 (PORTK) 中断，具体参照ATM2560手册
    PCICR |= (1 << PCIE2);      // 使能PCINT[23:16]端口中断
    PCMSK2 = 0xFF;              // 使能PORTK所有引脚的变化中断

    lastState_PCINT = PINK;     // 初始状态

	for (int i = 0; i < 4; i ++) {
		pos[i] = 0;
	}
	
	Serial.begin(115200);
}

void loop() {
	unsigned long now = millis();
	
	if (now - lastSampleTime >= SAMPLE_PERIOD_MS) {
		lastSampleTime = now;
		
		// 1. 原子读取当前pos[]数组（防止中断时读写冲突）
        long currentPos[4];
        noInterrupts();
        for (int i = 0; i < 4; ++i) currentPos[i] = pos[i];
        interrupts();
        
        // 2. 计算每轮脉冲增量
        long delta[4];
        for (int i = 0; i < 4; ++i) delta[i] = currentPos[i] - lastPos[i];

		// 3. 计算rpm（转/分）: (增量 / 线数) = 增量圈数, 1min=60000ms
        float rpm[4];
        for (int i = 0; i < 4; ++i) {
            rpm[i] = (float)delta[i] * (60000.0f / SAMPLE_PERIOD_MS) / ENCODER_LINES;
        }
        
        // 4. 更新lastPos
        for (int i = 0; i < 4; ++i) lastPos[i] = currentPos[i];
        
        rpmFR = rpm[0];
        rpmFL = rpm[1];
        rpmBR = rpm[2];
        rpmBL = rpm[3];
        
        Serial.print("FR:"); Serial.print(rpmFR);
        Serial.print(" FL:"); Serial.print(rpmFL);
        Serial.print(" BR:"); Serial.print(rpmBR);
        Serial.print(" BL:"); Serial.println(rpmBL);
	}
}
```

以上代码应该可以完美实现对于四轮对应编码器的监测控制. 但是对应的结构化仍然做的不够好, 这里给出结构化后的代码

```cpp
#include <PinChangeInterrupt.h>
#include <PinChangeInterruptBoards.h>
#include <PinChangeInterruptPins.h>
#include <PinChangeInterruptSettings.h>

constexpr int ENCODER_1_A = A8;
constexpr int ENCODER_1_B = A9;
constexpr int ENCODER_2_A = A10;
constexpr int ENCODER_2_B = A11;
constexpr int ENCODER_3_A = A12;
constexpr int ENCODER_3_B = A13;
constexpr int ENCODER_4_A = A14;
constexpr int ENCODER_4_B = A15;
constexpr int ENCODER_LINES = 11;
constexpr unsigned long DEFAULT_INTERVAL_MS = 50;  // 采样周期(ms)
static unsigned long lastSampleTime = 0;
static long lastPos[4] = {0};   // 上次脉冲数
static float rpmFR = 0, rpmFL = 0, rpmBR = 0, rpmBL = 0;  // 四轮转速
static volatile uint8_t lastState_PCINT = 0;
static volatile long pos[4] = {0};   // 四路编码器脉冲计数
static unsigned long nowTime = 0;

/*
* 相较于之前写的 ISR 循环, 这个循环在状态不改变的时候没有计算负担. 因此理论速度更快.
*/
ISR(PCINT2_vect) {
    uint8_t currentState = PINK;           // 读取A8~A15所有引脚状态
    uint8_t changedPins = currentState ^ lastState_PCINT; // 检测哪些引脚变化

    // 编码器1: PK0(A), PK1(B)
    if (changedPins & ((1 << 0) | (1 << 1))) {
        bool A = currentState & (1 << 0);
        bool B = currentState & (1 << 1);
        if (changedPins & (1 << 0)) {      // A跳变
            if (A == B) pos[0]++;
            else pos[0]--;
        } else {                           // B跳变
            if (A != B) pos[0]++;
            else pos[0]--;
        }
    }

    // 编码器2: PK2(A), PK3(B)
    if (changedPins & ((1 << 2) | (1 << 3))) {
        bool A = currentState & (1 << 2);
        bool B = currentState & (1 << 3);
        if (changedPins & (1 << 2)) {      // A跳变
            if (A == B) pos[1]++;
            else pos[1]--;
        } else {                           // B跳变
            if (A != B) pos[1]++;
            else pos[1]--;
        }
    }

    // 编码器3: PK4(A), PK5(B)
    if (changedPins & ((1 << 4) | (1 << 5))) {
        bool A = currentState & (1 << 4);
        bool B = currentState & (1 << 5);
        if (changedPins & (1 << 4)) {      // A跳变
            if (A == B) pos[2]++;
            else pos[2]--;
        } else {                           // B跳变
            if (A != B) pos[2]++;
            else pos[2]--;
        }
    }

    // 编码器4: PK6(A), PK7(B)
    if (changedPins & ((1 << 6) | (1 << 7))) {
        bool A = currentState & (1 << 6);
        bool B = currentState & (1 << 7);
        if (changedPins & (1 << 6)) {      // A跳变
            if (A == B) pos[3]++;
            else pos[3]--;
        } else {                           // B跳变
            if (A != B) pos[3]++;
            else pos[3]--;
        }
    }

    lastState_PCINT = currentState;        // 记录状态用于下次检测
}

void ISR_setup() {
    // 配置A8~A15为输入，并开启上拉
    for (int i = A8; i <= A15; i++) {
        pinMode(i, INPUT_PULLUP);
    }
    // 使能PCINT2 (PORTK) 中断，具体参照ATM2560手册
    PCICR |= (1 << PCIE2);      // 使能PCINT[23:16]端口中断
    PCMSK2 = 0xFF;              // 使能PORTK所有引脚的变化中断

    lastState_PCINT = PINK;     // 初始状态

	for (int i = 0; i < 4; i ++) {
		pos[i] = 0;
	}
}

void ISR_update();

void sensors_update() {
	ISR_update();
}

void setup() {
	ISR_setup();

	Serial.begin(115200);
}

void loop() {
	nowTime = millis();

	if (nowTime - lastSampleTime >= DEFAULT_INTERVAL_MS) {
		lastSampleTime = nowTime;
		sensors_update();
	}
}

void ISR_update() {
	lastSampleTime = nowTime;
		
	// 1. 原子读取当前pos[]数组（防止中断时读写冲突）
    long currentPos[4];
    noInterrupts();
    for (int i = 0; i < 4; ++i) currentPos[i] = pos[i];
    interrupts();
        
    // 2. 计算每轮脉冲增量
    long delta[4];
    for (int i = 0; i < 4; ++i) delta[i] = currentPos[i] - lastPos[i];

	// 3. 计算rpm（转/分）: (增量 / 线数) = 增量圈数, 1min=60000ms
    float rpm[4];
    for (int i = 0; i < 4; ++i) {
        rpm[i] = (float)delta[i] * (60000.0f / DEFAULT_INTERVAL_MS) / ENCODER_LINES;
    }
        
    // 4. 更新lastPos
    for (int i = 0; i < 4; ++i) lastPos[i] = currentPos[i];
        
    rpmFR = rpm[0];
    rpmFL = rpm[1];
    rpmBR = rpm[2];
    rpmBL = rpm[3];
        
    Serial.print("FR:"); Serial.print(rpmFR);
    Serial.print(" FL:"); Serial.print(rpmFL);
    Serial.print(" BR:"); Serial.print(rpmBR);
    Serial.print(" BL:"); Serial.println(rpmBL);
}
```


## PID 电控算法
---

示例代码

```cpp
// --- PID 参数（根据实际需求调试） ---
float Kp = 1.2;    // 比例系数
float Ki = 0.3;    // 积分系数
float Kd = 0.01;   // 微分系数

// --- 每个轮的目标转速（可根据需要动态赋值） ---
float target_rpmFR = 0;
float target_rpmFL = 0;
float target_rpmBR = 0;
float target_rpmBL = 0;

// --- 每个轮的 PID 中间变量与输出 ---
float errorFR = 0, lastErrorFR = 0, integralFR = 0, pwmFR = 0;
float errorFL = 0, lastErrorFL = 0, integralFL = 0, pwmFL = 0;
float errorBR = 0, lastErrorBR = 0, integralBR = 0, pwmBR = 0;
float errorBL = 0, lastErrorBL = 0, integralBL = 0, pwmBL = 0;

// --- 积分限幅防止积分过大导致震荡 ---
float integral_limit = 200.0;

void updatePID() {
    float dt = SAMPLE_PERIOD_MS / 1000.0f;   // 时间步长，单位：秒

    // ---------- 右前轮 FR ----------
    errorFR = target_rpmFR - rpmFR;                 // 当前误差
    integralFR += errorFR * dt;                     // 积分累加
    // 防止积分过大造成输出失控
    if (integralFR > integral_limit) integralFR = integral_limit;
    if (integralFR < -integral_limit) integralFR = -integral_limit;
    float derivativeFR = (errorFR - lastErrorFR) / dt; // 微分项
    pwmFR = Kp * errorFR + Ki * integralFR + Kd * derivativeFR; // PID输出
    lastErrorFR = errorFR;

    // ---------- 左前轮 FL ----------
    errorFL = target_rpmFL - rpmFL;
    integralFL += errorFL * dt;
    if (integralFL > integral_limit) integralFL = integral_limit;
    if (integralFL < -integral_limit) integralFL = -integral_limit;
    float derivativeFL = (errorFL - lastErrorFL) / dt;
    pwmFL = Kp * errorFL + Ki * integralFL + Kd * derivativeFL;
    lastErrorFL = errorFL;

    // ---------- 右后轮 BR ----------
    errorBR = target_rpmBR - rpmBR;
    integralBR += errorBR * dt;
    if (integralBR > integral_limit) integralBR = integral_limit;
    if (integralBR < -integral_limit) integralBR = -integral_limit;
    float derivativeBR = (errorBR - lastErrorBR) / dt;
    pwmBR = Kp * errorBR + Ki * integralBR + Kd * derivativeBR;
    lastErrorBR = errorBR;

    // ---------- 左后轮 BL ----------
    errorBL = target_rpmBL - rpmBL;
    integralBL += errorBL * dt;
    if (integralBL > integral_limit) integralBL = integral_limit;
    if (integralBL < -integral_limit) integralBL = -integral_limit;
    float derivativeBL = (errorBL - lastErrorBL) / dt;
    pwmBL = Kp * errorBL + Ki * integralBL + Kd * derivativeBL;
    lastErrorBL = errorBL;

    // ---- 输出限制到PWM范围（假设PWM范围0~255，正负可代表方向） ----
    pwmFR = constrain(pwmFR, -255, 255);
    pwmFL = constrain(pwmFL, -255, 255);
    pwmBR = constrain(pwmBR, -255, 255);
    pwmBL = constrain(pwmBL, -255, 255);

    // 可在此处直接输出PWM控制信号到电机
    // 例如（假设正负表示前进/后退，motorX_dir_pin是方向引脚，motorX_pwm_pin是PWM引脚）：
    // setMotorPWM(motorFR_dir_pin, motorFR_pwm_pin, pwmFR);
    // setMotorPWM(motorFL_dir_pin, motorFL_pwm_pin, pwmFL);
    // setMotorPWM(motorBR_dir_pin, motorBR_pwm_pin, pwmBR);
    // setMotorPWM(motorBL_dir_pin, motorBL_pwm_pin, pwmBL);
}

void setMotorPWM(int dirPin, int pwmPin, float pwmVal) {
    if (pwmVal >= 0) {
        digitalWrite(dirPin, HIGH);
        analogWrite(pwmPin, (int)pwmVal);
    } else {
        digitalWrite(dirPin, LOW);
        analogWrite(pwmPin, (int)(-pwmVal));
    }
}
```